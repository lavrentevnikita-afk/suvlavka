# Архитектура и деплой проекта

## Обзор

Проект **Souvenir Shop** — интернет-магазин сувениров с B2C и B2B-функциональностью, складским учётом и PWA-поддержкой.

Цель: продукт уровня «флагманского» интернет-магазина, но с чистой архитектурой и возможностью масштабирования.

Текущий стек:

- **Frontend**: Nuxt 3 (Vue 3, TypeScript), Pinia, TailwindCSS, PWA (@vite-pwa/nuxt).
- **UI-инфраструктура**: дизайн-токены, Storybook (отдельная витрина компонентов).
- **Тесты фронта**: Vitest (юнит), Playwright (e2e).
- **Backend**: NestJS (Node.js + TypeScript).
- **База данных**: PostgreSQL.
- **Кэш и очереди**: Redis.
- **Хранение изображений**:
  - на старте — локально на сервере (`/uploads`),
  - позже — внешнее/сетевое хранилище, подключенное к серверу.
- **CDN**: в перспективе — для статики и изображений.
- **Поиск**: на старте PostgreSQL + индексы, далее Meilisearch / OpenSearch.
- **Инфраструктура**: Docker + docker-compose для dev/stage, CI/CD (GitHub Actions / GitLab CI).

Все роли (гость, розница, магазины, менеджеры, админы) работают **на одном домене**.  
Различия в правах и ценах реализуются через авторизацию и ролевую модель.

---

## 1. Высокоуровневая архитектура

### 1.1. Компоненты

1. **Frontend (Nuxt 3 PWA)**  
   - SSR/CSR рендеринг интерфейсов:
     - публичный каталог,
     - личные кабинеты розницы и магазинов,
     - интерфейсы менеджера и администратора.
   - PWA-слой: offline-кеш, установка как приложение, обработка сети.

2. **Backend API (NestJS)**  
   - Модульная архитектура:
     - `Auth` — авторизация, JWT, роли.
     - `Users` — пользователи и профили магазинов.
     - `Catalog` — категории, товары, цены, изображения.
     - `Orders` — заказы, корзины, статусы.
     - `Warehouse` — склады, остатки, движения.
     - `B2B` — отдельная логика и отчёты для магазинов.
     - `Reports` — агрегированные данные и аналитика.
   - Отдаёт REST/JSON API для фронта.

3. **База данных (PostgreSQL)**  
   - Хранение доменных сущностей:
     - пользователи, магазины, роли,
     - товары, категории, цены,
     - заказы и позиции заказов,
     - склады, остатки, движения,
     - задачи производства, отгрузки,
     - аудиторские логи.
   - Используются индексы и представления для ускорения запросов.

4. **Redis**  
   - Кэш для:
     - часто запрашиваемых данных каталога,
     - сессий/блэклиста токенов (если нужно),
     - результатов тяжёлых запросов.
   - Очереди:
     - отправка почты/уведомлений,
     - фоновые задачи (обработка отчётов, импорты).

5. **Файловое хранилище (локальное на старте)**  
   - Каталог `uploads/` в файловой системе сервера:
     - `uploads/products/<product_id>/image_<n>.jpg`.
   - За отдачу файлов отвечает:
     - либо backend (NestJS static files),
     - либо reverse-proxy (Nginx) с маппингом URL → директории.
   - В дальнейшем:
     - перенос на подключённое сетевое хранилище,
     - минимальные изменения в коде за счёт абстракции «FileStorageService».

6. **CDN (в перспективе)**  
   - Для ускоренной раздачи статики (JS/CSS) и изображений.
   - На стартовом этапе можно раздавать статику напрямую с сервера.

---

## 2. Потоки данных

1. Пользователь открывает страницу магазина:
   - Запрос → Nuxt SSR на Node → HTML + данные первой загрузки.
2. Nuxt на сервере запрашивает данные у NestJS API:
   - `/api/catalog/categories`,
   - `/api/catalog/products`,
   - `/api/orders/...` и т.д.
3. NestJS:
   - читает/пишет в PostgreSQL,
   - при необходимости обращается к Redis (кэш),
   - отдаёт JSON-ответы фронтенду.
4. Изображения:
   - ссылки на файлы вида `/media/products/...`,
   - фактические файлы хранятся в локальном `uploads/` и отдаются сервером или Nginx.
5. PWA:
   - Кэширует статику и часть API-ответов,
   - Позволяет открывать каталог и корзину при плохой сети.

---

## 3. Роли и права

Роли реализуются на backend (NestJS Guards), данные о пользователе — в JWT.

Основные роли:

- **Guest** — гость (неавторизованный):
  - видит каталог и розничные цены,
  - может формировать гостевую корзину.
- **Retail** — розничный покупатель:
  - видит розничные цены,
  - имеет личный кабинет и историю заказов.
- **Store** — магазин (B2B):
  - видит **оптовые / индивидуальные цены**,
  - имеет быстрый заказ и свои отчёты.
- **Manager** — менеджер:
  - видит все заказы,
  - управляет их статусами,
  - работает со складом/производством.
- **Admin** — администратор:
  - полные права, включая управление пользователями, каталогом, ценами, ролями.

**Важно:**  
Нет разделения по доменам. Все пользователи заходят на **один и тот же сайт**, различия только в том, какие данные и действия им доступны.

---

## 4. Среды и конфигурация

Рекомендуемые окружения:

- `local` — локальная разработка (docker-compose или прямой запуск).
- `dev/stage` — тестовый стенд.
- `prod` — боевой сервер.

### 4.1. Переменные окружения (общие идеи)

Frontend (Nuxt):

- `NUXT_PUBLIC_API_BASE_URL` — URL backend API.
- `NUXT_PUBLIC_APP_NAME` — название приложения.
- `NUXT_PUBLIC_PWA_ENABLED` — включение/отключение PWA.

Backend (NestJS):

- `DATABASE_URL` — строка подключения к PostgreSQL.
- `REDIS_URL` — подключение к Redis.
- `JWT_SECRET` — секрет для токенов.
- `PORT` — порт API.
- `UPLOADS_DIR` — путь до папки с файлами (по умолчанию `uploads/`).

Инфраструктура (docker-compose):

- настройки сервисов Postgres, Redis, проброс портов, тома.

---

## 5. Деплой фронтенда

### 5.1. Сборка

```bash
cd frontend
npm install
npm run build
```

Nuxt создаёт `.output`:

- серверную часть (Node SSR),
- статические ресурсы.

### 5.2. Запуск в продакшене

Вариант 1: Node-процесс + Nginx:

```bash
NODE_ENV=production node .output/server/index.mjs
```

- Nginx:
  - завершает HTTPS,
  - раздаёт статику `/public` и `/uploads`,
  - проксирует `/(?!uploads|_nuxt)` на Nuxt SSR,
  - проксирует `/api/` на NestJS.

Вариант 2: Docker (рекомендуется):

- Dockerfile для frontend:
  - стадия сборки,
  - стадия рантайма (Node + `.output`).
- Управление через docker-compose / orchestrator.

---

## 6. Деплой backend (NestJS)

### 6.1. Сборка и запуск

```bash
cd backend
npm install
npm run build
npm run start:prod
```

Или в dev-режиме:

```bash
npm run start:dev
```

Backend поднимается, например, на `http://localhost:4000`  
(значение задаётся через `PORT`).

### 6.2. Миграции БД

Рекомендуется использовать ORM (TypeORM / Prisma):

- описать модели (users, products, orders, warehouses, movements и т.п.),
- настроить миграции,
- включить запуск миграций при деплое.

---

## 7. Docker и docker-compose

Для удобства разработки и тестирования будет использоваться `docker-compose` со следующими сервисами:

- `frontend` — Nuxt 3 dev/prod.
- `backend` — NestJS.
- `db` — PostgreSQL.
- `redis` — Redis.
- (позже) `search` — Meilisearch / OpenSearch.

Пример базовой команды:

```bash
docker-compose up --build
```

---

## 8. PWA и кеширование

PWA на фронте:

- кэш статических ресурсов (`_nuxt/**`, иконки, CSS, JS),
- кэш публичных API запросов:

  - `cache-first` для статики,
  - `stale-while-revalidate` для каталога,
  - `network-first` для заказов и личных данных.

---

## 9. Локальное хранение изображений и миграция

### 9.1. На старте

- Загруженные изображения товаров сохраняются в локальную директорию `uploads/`.
- URL вида `/media/products/...` маппятся на эту директорию.
- Backup/резервное копирование реализуется через бэкапы файловой системы.

### 9.2. Позже

Когда появится подключённое хранилище (NAS / внешнее облако):

- `uploads/` монтируется как внешний том (NFS/SMB/облако).
- Код приложения не меняется, меняется только путь/монтаж хранилища.
- Для CDN:
  - можно проксировать `/media` через CDN,
  - либо выгружать оптимизированные версии картинок в отдельный бакет.

---

## 10. Масштабирование

На старте:

- один инстанс frontend (Nuxt),
- один инстанс backend (NestJS),
- один PostgreSQL,
- один Redis.

При росте:

- несколько инстансов frontend/backend за балансировщиком,
- отдельный кластер БД (репликация, read-only реплики),
- выделенный кластер Redis,
- вынос хранилища изображений на выделенный ресурс,
- подключение CDN.

---
